---
title: 파이썬으로 선택정렬 풀어보기
description: <center> Algorithm_with_python </center>
categories:
 - Algorithm
tags:
---

## 정렬
알고리즘 공부의 꽃 이라 할 수 있는 정렬 문제입니다. 자료를 크기 순서대로 맞춰 일렬로 나열하는 것입니다. 리스트에 들어 있는 숫자를 크기순으로 나열하는 정렬 알고리즘의 입출력은 다음과 같이 정리할 수 있습니다.

* 문제: 리스트 안에 있는 자료를 순서대로 배열하기
* 입력: 정렬할 리스트(예: [35, 9, 2, 85, 17])
* 출력: 순서대로 정렬된 리스트 (예: [2, 9, 17, 35, 85])

## 선택 정렬로 줄 세우기
자료를 정렬하는 컴퓨터 알고리즘을 살펴보기에 앞서, 운동자에 모인 학생을 순서에 맞춰 일렬로 줄 세우는 방법을 한 번 생각해 보겠습니다.

1. 학생 열 명이 모여 있는 운동장에 선생님이 등장합니다.
2. 선생님은 학생들을 둘러보며 키가 가장 작은 사람을 찾습니다. 키가 가장 작은 학생으로 선택된 학생이 맨 앞에 섭니다. 이제 학생은 9명이 남았습니다. 
3. 이처럼 남아 있는 학생 중에서 키가 가장 작은 학생을 한 명씩 뽑아 줄에 세우는 과정을 반복하면 모든 학생이 키 순서에 맞춰 줄을 서게 됩니다.

## 쉽게 설명한 선택 정렬 알고리즘

```python
# 쉽게 설명한 선택 정렬
# 입력: 리스트 a
# 출력: 정렬된 새 리스트
# 주어진 리스트에서 최솟값의 위치를 돌려주는 함수

def find_min_idx(a):
    n = len(a)
    min_idx = 0
    for i in range(1, n):
        if a[i] < a[min_idx]:
            min_idx = i
    return min_idx

def sel_sort(a):
    result = [] # 새 리스트를 만들어 정렬된 값을 저장
    while a: # 주어진 리스트에 값이 남아 있는 동안 계속
        min_idx = find_min_idx(a) # 리스트에 남아 있는 값 중 최솟값의 위치
        value = a.pop(min_idx) # 찾은 최솟값을 빼내어 value에 저장
        result.append(value) # value를 결과 리스트 끝에 추가
    return result

d = [2, 4, 5, 1, 3]
print(sel_sort(d))
```
실행결과

```python
[1, 2, 3, 4, 5]
```

프로그램을 차근히 읽어 보면 앞에서 설명한 줄 서기 원리가 잘 녹아 있습니다.

1. 리스트 a에 아직 자료가 남아 있다면 -> `while a :`
2. 남은 자료 중에서 최솟값의 위치를 찾습니다. -> `min_idx = find_min_idx(a)`
3. 찾은 최솟값을 리스트 a에서 빼내어 value에 저장합니다. -> `value = a.pop(min_idx)`
4. value를 result 리스트의 맨 끝에 추가합니다. -> `result.append(value)`
5. 1번 과정으로 돌아가 자료가 없을 때까지 반복합니다.


## 일반적인 선택 정렬 알고리즘

```python

# 선택 정렬
# 입력: 리스트 a
# 출력: 없음(입력으로 주어진 a가 정렬됨)
import random

def sel_sort(a):
    n = len(a)
    for i in range(0, n-1): # 0부터 n-2까지 반복
        # i번 위치부터 끝까지 자료 값 중 최솟값의 위치를 찾음
        min_idx = i
        for j in range(i+1, n):
            if a[j] < a[min_idx]:
                min_idx = j
                # 찾은 최솟값을 i번 위치로
        a[i], a[min_idx] = a[min_idx], a[i]

d = list()
for i in range(10):
    d.append(random.randrange(100))
sel_sort(d)
print(d)
```

실행결과

```python
[10, 12, 27, 31, 36, 45, 50, 64, 64, 83]
```

## 알고리즘 분석
자료를 크기 순서로 정렬하려면 반드시 두 수의 크기를 비교해야 합니다. 따라서 정렬 알고리즘의 계산 복잡도는 보통 비교 횟수를 기준으로 따집니다. 선택 정렬의 비교 방법은 동명이인 찾기에서 살펴본, 리스트 안의 자료를 한 번씩 비교하는 방법과 거의 같습니다. 계산 복잡도는 O(n^2)입니다.

#### 마치며
이번에는 선택 정렬을 구하는 방법을 알아보았습니다. 위에서 설명하는 내용은 `모두의 알고리즘 with python`이라는 책을 참고하고 있습니다. 책을 구매하시면 더 많은 내용과 설명이 있습니다.