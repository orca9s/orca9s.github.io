---
title: 파이썬으로 팩토리얼 구하기(재귀 호출)
description: <center> Algorithm_with_python </center>
categories:
 - Algorithm
tags:
---

## 팩토리얼

팩토리얼은 1부터 n까지 연속한 숫자를 차례로 곱한 값 입니다. 팩토리얼 프로그램은 1부터 n까지의 합을 구하는 알고리즘을 조금만 고치면 만들 수 있습니다. 

```python
# 연속한 숫자의 곱을 구하는 알고리즘
# 입력: n
# 출력: 1부터 n까지 연속한 숫자를 곱한 값

def fact(n):
    f = 1 # 곱을 계산할 변수, 초깃값은 1
    for i in range(1, n+1): # 1부터 n까지 반복(n+1은 제외)
        f = f * i # 곱셈 연산으로 수정
    return f

print(fact(1)) # 1! = 1
print(fact(5)) # 5! = 120
print(fact(10)) # 10! = 3628800
```
실행 결과

```python
1
120
3628800
```
위의 방식에서는 재귀 호출을 사용하지 않았지만 재귀 호출 방식으로 팩토리얼을 구하는 알고리즘을 만들어 보겠습니다.

## 러시아 인형

러시아 인형중에 큰 인형을 열면 그 안에 비슷하게 생긴 작은 인형이 있고, 또 그 안에 더 작은 인형들이 반복해서 들어있는 인형을 본적이 있을 겁니다. 마지막 인형 안에는 상품이 들어있는 경우도 있습니다. 재귀함수는 이와 비슷하다고 생가하면 됩니다.

## 재귀 호출: 다시 돌아가 부르기

재귀 호출은 어떤 함수 안에서 자기 자신을 부르는 것을 말합니다.
<br>
아래의 프로그램을 한번 보겠습니다.

```python
def hello():
	print('hello')
	hello() # hello()함수 안에서 다시 hello()를 호출

hello() # hello()함수를 호출
```

hello()함수의 정의를 보면 `hello`라는 문장을 출력한 다음 자기 자신인 hello()를 다시 호출합니다. 이것이 바로 재귀 호출입니다. 다만 위의 코드에서는 탈출 조건을 정의하지 않아서 `hello`를 출력하는 과정을 영원히 반복하게 됩니다. 컴퓨터는 `hello`를 계속 출력하다가 결국에는 기억 장소를 다 써 버리고 에러를 내고 정지해 버립니다.
<br>
<br>
재귀 호출 프로그램이 정삭적으로 작동하려면 `종료 조건`이 필요합니다. 즉, 특정 조건이 되면 더는 자신을 호출하지 않고 멈추도록 설계되어야만 합니다. 그렇지 않을 경우 위와 같이 에러가 발생합니다.
<br>
재귀 호출 함수가 계산 결과를 돌려줄 때는 `return`명령을 사용해서 종료 조건의 결과값부터 돌려줍니다. 종료 조건의 결과값은 곧 마지막으로 호출된 함수의 결과값이므로 마지막 인형 안에 들어 있는 상품과 비슷한 개념입니다.

## 재귀 호출 알고리즘

팩토리얼을 재귀 호출로 표현하면 다음과 같습니다.

```python
1! = 1
2! = 2 x 1 = 2 x 1!
3! = 3 x (2 x 1) = 3 x 2!
4! = 4 x (3 x 2 x 1) = 4 x 3!

....

n! = n x (n-1)!

```

여기서 1! = 1 그리고 n! = n x (n - 1)!이라는 팩토리얼의 성질을 이용해서 팩토리얼을 구하는 프로그램을 만들어 보겠습니다.

```python
# 연속한 숫자의 곱을 구하는 알고리즘
# 입력:n
# 출력: 1부터 n까지 연속한 숫자를 곱한 값

def fact(n):
    if n <= 1:
        return 1
    return n * fact(n-1)
print(fact(1))
print(fact(5))
print(fact(10))
```
실행 결과

```python
1
120
3628800
```

우선 n이 1 이하인지 비교합니다. 1이하는 더는 계산하지 않아도 되는 `종료조건`입니다. 이때 1을 결괏값으로 돌려줍니다.(마지막 인형 안에 들어있는 상품에 해당합니다) n이 1보다 크면 `n! = n x (n -1)!` 이므로 `n * fact(n-1)`을 결괏값으로 돌려줍니다. 이 과정에서 n!을 구하기 위해서 더 작은 값인 `(n-1)!`을 구하는 `fact(n-1)`이 재귀 호출됩니다.(인형 안에 들어 있는 조금 더 작은 인형에 해당) 아직 재귀 함수의 작동 방법이 헷갈릴 겁니다. 우선 위의 코드를 이용해 fact(4)를 호출한다고 가정하고 사람의 언어로 풀어보겠습니다.
<br>

1. fact(4)는 4 * fact(3)이므로 fact(3)을 호출하고
2. fact(3)은 3 * fact(2)이므로 fact(2)를 호출하고
3. fact(2)는 2 * fact(1)이므로 fact(1)을 호출합니다.
4. fact(1)은 종료 조건이기 때문에 fact()함수를 더 이상 호출하지 않고 1을 return합니다.
5. fact(2)는 fact(1)에서 돌려받은 결괏값 1에 2를 곱해 2를 돌려주고
6. fact(3)은 fact(2)에서 돌려받은 결괏값 2에 3을 곱해 6을 돌려주고
7. fact(4)는 fact(3)에서 돌려받은 결괏값 6에 4를 곱해 24를 최종결과로 돌려줍니다.

```python
fact(4)
-> 4 * fact(3)
		-> 3 * fact(2)
				-> 2 * fact(1)
					-> 1(n이 1이므로 종료 조건)
				-> 2 * 1
		-> 3 * 2 * 1
-> 4 * 3 * 2 * 1 = 24(최종결과)
```

```python
4!
= 4 x 3!
= 4 x 3 x 2!
= 4 x 3 x 2 x 1!
= 4 x 3 x 2 x 1(1은 종료 조건이므로 재귀 호출을 멈춤)
= 4 x 3 x 2
= 4 x 6
= 24
```

## 알고리즘 분석

팩토리얼은 연속한 수의 곱이므로 곱셈의 횟수를 기준으로 알고리즘 분석을 하겠습니다.
<br>
for 반복문을 이용한 프로그램의 경우 n!을 구하려면 곱셈이 n번 필요합니다. 재귀 호출 알고리즘으로 만들어진 팩토리얼은 위의 경우를 보았을 때 총 세번의 곱셈이 필요합니다. n!을 구하려면 곱셈이 n-1번 필요하다는 것을 알 수 있습니다.<br>
반복문을 이용한 알고리즘이나 재귀 호출을 이용한 알고리즘의 계산 복잡도는 모두 O(n)입니다.

## 응용

앞에서 배운 1부터 n까지의 합 구하기를 재귀 호출로 만들어 보겠습니다.

```python
def sum_n(n):
    if n <= 1:
        return 1
    return n + sum_n(n-1)


print(sum_n(2))
print(sum_n(10))
print(sum_n(100))
```
실행 결과

```python
3
55
5050
```
위의 코드는 제가 작성한 코드인데 책에서 설명하는 방법과 달라서 올려 보았습니다. 무엇이 맞는지는 모르겠습니다. 아래의 코드는 책에서 설명하는 방법입니다. 주의 할 점은 제가 만든 코드는 n에 음수가 들어갈 경우에도 1을 리턴시키지만 책에서 설명한 코드는 n값에 음수가 들어갈 경우 에러가 발생합니다.

```python
# 연속한 숫자의 합을 구하는 알고리즘
# 입력: n
# 출력: 1부터 n까지 연속한 숫자를 더한 값

def sum_n(n):
    if n == 0:
        return 0
    return sum_n(n-1) + n

print(sum_n(2))
print(sum_n(10))
print(sum_n(100))
```
실행 결과

```python
3
55
5050
```

숫자 n개 중에서 최댓값 찾기를 재귀 호출로 풀어보겠습니다.

```python
# 최댓값 구하기
# 입력: 숫자가 n개 들어 있는 리스트
# 출력: 숫자 n개 중 최댓값

def find_max(a, n): # 리스트 a의 앞부분 n개 중 최댓값을 구하는 재귀 함수
    if n == 1:
        return a[0]
    max_n_1 = find_max(a, n-1) # n-1개 중 최댓값을 구함
    if max_n_1 > a [n-1]: # n-1개 중 최댓값과 n-1번 위치 값을 비교
        return max_n_1
    else:
        return a[n - 1]
    
v = [17, 92, 18, 33, 58, 7, 33, 42]
print(find_max(v, len(v))) # 함수에 리스트의 자료 개수를 인자로 추가하여 호출
```
실행 결과

```python
92
```

#### 마치며
이번에는 재귀 호출을 사용하고 재귀 호출을 이용해 팩토리얼을 구하는 방법을 알아보았습니다. 위에서 설명하는 내용은 `모두의 알고리즘 with python`이라는 책을 참고하고 있습니다. 책을 구매하시면 더 많은 내용과 설명이 있습니다.